package cormen.введение.theory

fun main(){
    val arrayExample = arrayOf(5,2,4,6,1,3)
    println(arrayExample.toList())
    insertionSort(arrayExample)
    println(arrayExample.toList())

}

// Обходит каждый элемент массива слева направо j
// Для каждого j-го элемента все левые элементы обходит (не включай j-й)
// Обходит влево от j, если левый больше j-го
// Каждый i-й, что больше j-й, будет сдвинут вперед (пустота в j)
// j-й переместить


// Обходить можно в обе стороны
// Сортировка возможна сразу при поступлении (in place) (без доп памяти)
// Обратный отсортированный массив является худшим случаем
// Чем ближе массив к отсортированному состоянию, тем быстрее сортировка (нет лишних действий)

fun insertionSort(array: Array<Int>){
    for (j in 1 until array.size){            // c1 n-1+1 = n (1 за выход из цикла)
        val key = array[j]                          // c2 n-1
        var i = j-1                                 // c3 n-1
        while (i >= 0 && array[i] > key){            // c4 ∑n-1|j=1 (Tj)
            array[i+1] = array[i]                   // c5 ∑n-1|j=1 (Tj -1) (1 за выход из цикла)
            i--                                     // c6 ∑n-1|j=1 (Tj -1)
        }
        array[i+1] = key                            // c7 n-1
    }
}

// Формула арифметической прогрессии
// кол-во элементов*(первый + последний)/2 =  ∑n|j=1 = n*(1 + n)/2

// c4∑n-1|j=1  (j)=     (n-1)*(1+n-1)/2 = (n-1)n/2      = (n^2+2n-n-2)/2    = n(n+1)/2-1
// c5∑n-1|j=1 (j-1) =   (n-1)*(0+n-2)/2 = (n-2)(n-1)/2  = (n^2-n-2n+2)/2    = n(n-3)/2+1

// Суммарное число операций
// T(n) = c1n + c2(n-1) + c3(n-1) + c4∑n-1|j=1 (Tj) + c5∑n-1|j=1 (Tj-1) + c6∑n-1|j=1 (Tj-1) + c7(n-1)

// Нижняя граница
// Учитывая, что в лучшем случае условие array[i] > key будет всегда нарушаться, следует константное время для Tj (c5 и c6 отбрасываются)
// Tj = const = 1
// T(n) = Cn-C
// Линейно

// Верхняя граница
// В худшем случае условие array[i] > key всегда срабатывает, следует Tj = j
// T(n) = Cn^2 + Cn - C
// Квадратично