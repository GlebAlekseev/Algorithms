package cormen.c6_7_8_сортировка.c7_quicksort.p7_1

fun main(){
    val arrayExample = arrayOf(13,9,9,5,12,8,7,4,21,2,6,11)
    println(arrayExample.toList())
    cormen.c6_7_8_сортировка.theory.quickSort(arrayExample, 0, arrayExample.size - 1)
    println(arrayExample.toList())
}

// j=0 array=[13, 9, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11]
// j=1 array=[9, 13, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11]
// j=2 array=[9, 9, 13, 5, 12, 8, 7, 4, 21, 2, 6, 11]
// j=3 array=[9, 9, 5, 13, 12, 8, 7, 4, 21, 2, 6, 11]
// j=4 array=[9, 9, 5, 13, 12, 8, 7, 4, 21, 2, 6, 11]
// j=5 array=[9, 9, 5, 8, 12, 13, 7, 4, 21, 2, 6, 11]
// j=6 array=[9, 9, 5, 8, 7, 13, 12, 4, 21, 2, 6, 11]
// j=7 array=[9, 9, 5, 8, 7, 4, 12, 13, 21, 2, 6, 11]
// j=8 array=[9, 9, 5, 8, 7, 4, 12, 13, 21, 2, 6, 11]
// j=9 array=[9, 9, 5, 8, 7, 4, 2, 13, 21, 12, 6, 11]
// j=10 array=[9, 9, 5, 8, 7, 4, 2, 6, 21, 12, 13, 11]

// Функция partition получает на вход массив и диапазон
// Выбирает опорную точку pivot (последний элемент в диапазоне)
// Относительно нее размещает свопами элементы так, чтобы слева были те что меньше,
// а справа те, что больше
// На последнем шаге pivot перемещается на свое место - между меньшими и большими элементами
// Вернется индекс pivot

// Таким образом, функция разбивает исходный диапазон на три множества
// {pivot} {elements<=pivot} {elements>pivot}
// Для каждого диапазона size>1 будет рекурсивно вызван quickSort

